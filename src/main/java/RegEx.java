import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegEx {
    public static void main(String[] args) {
        //Квантификаторы:
        //{1,3},{1,},
        // Отдельного внимания заслуживают квантификторы: ?,*,+:
        // каждый из этих квантификаторов может работать в 3 режимах:

        //      1) жадный(дефолтный, жрет больше всего ресурсов)
//        Обычный квантификатор изначально является "жадным" (greedy). Жадный
//        квантификатор в первую очередь стремится обнаружить совпадение со всей строкой. Он
//        захватывает столько, сколько может, целую строку, пытаясь обнаружить совпадение. Если
//        первая попытка оказывается неудачной, он возвращается на один символ и повторяет
//        попытку. Этот процесс называют бектрекингом или поиском с возвратом. Пошаговый
//        возврат на один символ продолжается до тех пор, пока не будет обнаружено совпадение
//        или не исчерпаются все символы. Кроме того, жадный квантификатор сохраняет
//        информацию о каждом своем действии и поэтому потребляет наибольшее количество ресурсов

        //      2) сверхжадный(+)
//        Сверхжадный (possessive) квантификатор пытается найти совпадение, захватывая
//        целиком всю строку, но делает это в рамках одной попытки, не прибегая к поиску с
//        возвратом. Чтобы превратить обычный квантификатор в сверхжадный, перед ним необходимо
//        записать знак "плюс" (+). Сверхжадный квантификатор не тратит время на
//        "пережевывание" строки, а "глотает" ее целиком и только после этого пытается понять, а что же
//        именно он "съел".

        //      3) ленивый(?)
//        Ленивый (lazy) квантификатор (другое название — нежадный) действует иначе. Он
//        пытается обнаружить совпадение, начиная с самого первого символа тестируемой
//        строки. Далее он просматривает всю строку по одному символу за раз в поиске совпадения.
//        Наконец, он пытается найти совпадение со всей строкой. Чтобы превратить обычный
//        квантификатор в ленивый, перед ним необходимо записать вопросительный знак (?).


        // ?(один или более),*(ноль или болеее),+(1 или более) - последовательность из идущих ПОДРЯД символов!!
        Pattern p1 = Pattern.compile("\\d{2}");
        Matcher m1 = p1.matcher("a0fas1fa2s");
        if (m1.find()) {
            System.out.println(m1.group()); //пустой вывод
        }

        //Именнованные группы.
        //По умолчанию группы имеют номера 0,1,2,3,4. Где 0 - это вся строка.
        //При успешном поиске каждая группа захватит какую-то часть текста: первая — в первый буфер,
        //вторая — во второй, и так далее.При жежелании группу можно исключить из нумерации, то есть лишить её «захватнической» функции,
        // оставив только группирующую. Для этого вместо ограничителей группы (...) используем (?:...)

        //Сделать алиас для группы (?<имя группы>выражение)
        //Обратиться к этому алиасу (\\k<имя группы>)

        //Захваченные в буферы части строки могут использоваться двумя путями.
        // 1) прога, использующая регулярное выражение для поиска или замены, может обратиться к буферам как к специальным переменным.
        // 2) вторая возможность предусматривает использование ссылок на группы прямо в регулярном выражении.
        //      при таком использовании мы будем искать один и те же, ПОВТОРЯЮЩИЕСЯ символы. Например под группой <g1> нащлось слово "Катя"
        //      в дальнейшем и ссылке на эту группу в регулярке будет повторно искаться слово "Катя"
        Pattern p2 = Pattern.compile("(?<myGroup>2{2}).{5}\\k<myGroup>");
        Matcher m2 = p2.matcher("afas122adada22fa1s");
        if (m2.find()) {
            System.out.println(m2.group("myGroup"));
            System.out.println("Ура!");
        }

        //интернационализация символов
        Pattern p3 = Pattern.compile("[\\p{Alpha}]++", Pattern.UNICODE_CHARACTER_CLASS);
        Matcher m3 = p3.matcher("AFafaпафы你好ü");
        if (m3.find()) {
            System.out.println(m3.group());
        }
    }
}
