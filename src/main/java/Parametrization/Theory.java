package Parametrization;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Theory<T> {
    //Особенности параметризации:
    // - статические методы нужно параметризовать отдельно. Параметризация метода и параметризация класса - это разные сущности
    private static <T> void pr(T e) {
    }

    // - то же самое относится и к обычным методам. Параметризация метода и параметризация класса - это разные вещи
    // тут T в методе - это не параметр класса. А именно отдельный независимый параметер метода. Но если убрать
    // <T> из метода, то будет браться из параметра класса
    private <T> void print(T e) {
    }

    // - статические поля не могут иметь параметризации. Что будет, если каждый раз static переменной, которая существует
    // в единственном экземпляре присваивать разные типы???
    // - нестатические переменные могут иметь параметризацию. Они будут распараметризованы при создании объекта.
    T var;
    // Я обязан при создании объекта распараметризовать поля. Если же я этого не сделаю, то ссылка с generic-переменной
    // будет null.
    // TODO ВАЖНО: если объект параметризован, то и ссылка на него должна быть параметризована ТАК ЖЕ!
    // Theory<Number> t = new Theory<Integer>() - ОШИБКА!
    // TODO ВАЖНО:Однако параметризация, например, коллекций, позволяет добавлять в коллекцию с параметром Number объекты Integer,
    // Double, Float и прочее
    // Если у ссылка я не указываю тип параметра, то она банально будет параметризована типом Object:
    // Theory t = new Theory<Object>() - параметризация типом Object
    // Theory t = new Theory<>() - такая параметризация допускается благодаря diamond оператору
    // Diamond оператор высчитает тип параметра у объекта по ссылке, на которую он ссылается:
    // Theory<String> theory = new Theory<>();

    //extends:
    //позволяет гарантировать доступность не только методов Object, но и методов класса родителя
    //добавляет ограничение на тип параметра

    //wildcard:
    //накладывает дополнительные ограничения на параметр метода. В принципе аналогичное делает и параметриз. класса
    // Тоже может использовать extends
    //Пример:
    //текущий класс Theory не параметризованный, метод статический, а объект класса Message, который используется
    //внтури статического метода Theory, параметризованный Message<? extends Number> m; в таком случае использовать
    //T нельзя, класс Theory не параметризованный, а вот ? использовать можно без проблем.

    // помнить для чего писать <? extends T> и <? super T>

    //


    Theory() {
    }

    // - статические методы могут иметь параметризацию, если им передается тип параметров указанных


    public static void main(String[] args) {
        Theory<String> theory = new Theory<String>();

        ArrayList<Number> list = new ArrayList<>();
        Collections.addAll(list, new Double(2));
        list.add(new Integer(2));
        list.add(new Double(2));
        for (Number m :
                list) {
            System.out.println(m);
        }

        List<?> intList = new ArrayList<Integer>();
        //TODO java запрещает вызывать методы, которые могут добавить невалидные значения в коллекцию
        //TODO хотя создать такую коллекцию можно.
        // Ошибка
        // intList.add(new Integer(10));
    }

    class Car {
        public ArrayList<Car> createPoliceCars(int count) {
            ArrayList<Car> result = new ArrayList<Car>();

            for (int i = 0; i < count; i++) {
                final int number = i;
                result.add(new Car() {
                    public String toString() {
                        return "" + number;
                    }
                });
            }
            return result;
        }
    }


}
