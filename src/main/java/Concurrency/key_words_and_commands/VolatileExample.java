package Concurrency.key_words_and_commands;

public class VolatileExample {
	/* TODO общая теория:
	 * Чтобы ускорить свою работу, процессор копирует самые часто используемые переменные из области памяти в свой кэш
	 * и все изменения с ними производит в этой быстрой памяти. А после – копирует обратно в «медленную» память.
	 * Медленная память все это время содержит старые(!) (неизмененные) значения переменных.
	 * Чтобы пофиксить эту проблему Было придумано специальное ключевое слово volatile.
	 * Использование этого слова перед переменной принудительно всегда читало и писало ее только в обычную (медленную)
	 * память.
	 *
	 * volatile ДЕЙСТВИТЕЛЬНО гарантирует:
	 *
	 * 1. Visibility (видимость)
	 *    - Запись в volatile переменную сразу видна всем потокам
	 *    - Чтение всегда видит последнюю запись
	 *
	 * 2. Happens-before
	 *    - Запись happens-before чтению
	 *    - Все действия до записи видны после чтения
	 *
	 * 3. Атомарность для 64-bit типов
	 *    - long/double читаются/пишутся атомарно
	 *
	 * volatile НЕ гарантирует:
	 *
	 * 1. Атомарность составных операций
	 *    - volatile++ не атомарен
	 *
	 * 2. Видимость изменений внутри объекта
	 *    - object.field изменение может не быть видно
	 *
	 * TODO: Память
	 * ИЕРАРХИЯ ПАМЯТИ (скорость увеличивается сверху вниз):
	 *
	 * Регистры CPU              - ~1 такт (самая быстрая)
	 *        ↓
	 * L1 кэш (ядро)            - ~2-4 такта
	 *        ↓
	 * L2 кэш (ядро)            - ~10-20 тактов
	 *        ↓
	 * L3 кэш (общий для CPU)    - ~30-50 тактов
	 *        ↓
	 * Оперативная память (RAM)  - ~100-300 тактов (самая медленная)
	 *        ↓
	 * SSD/HDD (виртуальная память) - в миллионы раз медленнее
	 *
	 *
     * ПРИМЕРНЫЕ ЗНАЧЕНИЯ (в наносекундах):
     *
     * Регистр CPU:               0.3 нс
     * L1 кэш:                    1 нс
     * L2 кэш:                    4 нс
     * L3 кэш:                   15 нс
     * RAM:                     100 нс
     * SSD:                150,000 нс (150 мкс)
     * HDD:             10,000,000 нс (10 мс)
     *
     * Разница между L1 и RAM: в 100 раз!
     *
	 * TODO как применять volatile:
	 *
	 * БЕЗ VOLATILE (обычная переменная):
	 *
	 * Шаг 1: int x = sharedVariable;
	 *         Процессор: "А есть ли x в кэше?"
	 *         Если нет - загружаем из RAM в кэш
	 *
	 * Шаг 2: x++ (изменение)
	 *         Процессор: меняет значение В КЭШЕ
	 *
	 * Шаг 3: // работа продолжается
	 *         Процессор: работает с КЭШЕМ, RAM не трогает
	 *
	 * Шаг 4: // когда-нибудь потом
	 *         Кэш синхронизируется с RAM (cache flush)



	 * С VOLATILE:
	 *
	 * Шаг 1: int y = volatileVariable;
	 *         Процессор: читает ПРЯМО ИЗ RAM (кэш игнорируется)
	 *
	 * Шаг 2: y++ (изменение)
	 *         Процессор: меняет значение
	 *
	 * Шаг 3: volatileVariable = y;
	 *         Процессор: записывает ПРЯМО В RAM (немедленно!)
	 */
	//https://www.javatpoint.com/volatile-keyword-in-java
	private static volatile long counter = 1;

	public static void main(String[] args) {
		for (int i = 0; i<100; i++){
			Thread thread1 = new Thread(()->{counter++;
				System.out.println(counter);});
			thread1.start();
		}
	}
}
