import java.io.PrintStream;

import static jdk.nashorn.internal.objects.Global.Infinity;
import static jdk.nashorn.internal.objects.Global.NaN;

public class Primitives {
    int i5;
    char c4;
    boolean bol1;
    static  int i6;
    // Базовые типы - эти типы, доступные в рамках самого языка, для их использования не нужно создавать
    // свои классы или обращаться к классам из библиотеки. Переменные перечисленных типов даже не являются объектами
    // и размещаются в стековой памяти.


    public static void main(String[] args) {
        // ЛИТЕРАЛЫ
        //челочисл. литералам присваивается значение int. Поэтому при присвоение long надо писать long a = 4233l;
        //это правило не относится к byte и short. Для них можно писать byte b = 10;
        int i0 = 100_000;
        int i1 = -300; //десят. сист счисл
        int i2 = 0b101; // двоичная
        int i3 = 071; // восьмеричная
        int i4 = 0x521b; // шестнадцатиричная
        double d0 = +-0.2;//;
        double d1 = NaN; // не число, извлечение квадратного корня из отриц числа, деление на 0
        double d2 = Infinity;
        double d3 = 2.5;
        double d4 = 2e-1;

        // символьные литералы. для них используется кодировка Unicode в соответствии с которой для каждого символа отводится 2 байта
        // Символ можно задать в соответствии с двумя таблицами Unicode и ASCII
        char c1 = '\n';
        // Unicode
        char c2 = '\u1212'; // шестнадцатирич. предтавление символа. Min - \u0000 (0) max \uffff (65535)
        char c3 = '\212';// восьмерич. представление символа
        // ASCII
        char c4=120;
        //при работе с char действует автоупаковка
        float test='c';
        System.out.println("символ: " +test);

        // ПРИВЕДЕНИЕ ТИПОВ
        // При арифетических операциях автоматически происходит расширение типов: byte -> short -> int -> long -> float -> double.
        byte b1 = 2;
        double d5 = i0 + c1 + d3;
        float f1 = 2.4f;
        float i5 = b1 + i0 + f1;
        // для сужающих операций необходимо производить явное преобразование. Тут возможно потеря значения.
        // Обрезание происходит по схеме: ЧИСЛО - МАКС.ЗНАЧ.ТИПА
        // Пример: int i = -300;
        // byte b = (byte)i;
        // b = -300-(-256)=-44
        //
        byte b2 = (byte) i1;
        System.out.println(b2);

        //Приведение типов при работе с константами и  сокращенными операторами:

        byte b3 = 1, b4 = 1 + 2;
        final byte B = 1 + 2;
        //b3 = b4 + 1; // ошибка приведения типов int в byte
        /* переменная b4 на момент выполнения кода b3 = b4 + 1; может измениться, и выражение b4 + 1
        может превысить допустимый размер byte- типа */
        System.out.println(+b3);
        b3 = (byte) (b4 + 1);
        b3 = B + 1; // работает
        /* B - константа, ее значение определено, компилятор вычисляет значение выражения B + 1,
        и если его размер не превышает допустимого для byte типа, то ошибка не возникает */
        //b3 = -b3; // ошибка приведения типов
        b3 = (byte) -b3;
        //b3 = +b3; // ошибка приведения типов
        b3 = (byte) +b3;
        int i = 3;
        //b3 = i; // ошибка приведения типов, int больше, чем byte
        b3 = (byte) i;
        final int D = 3;
        b3 = D; // работает
        /* D –константа. Компилятор проверяет, не превышает ли ее значение допустимый размер для
        типа byte, если не превышает, то ошибка не возникает */
        final int D2 = 129;
        //b3=D2; // ошибка приведения типов, т.к. 129 больше, чем допустимое 127
        b3 = (byte)D2;
        b3+= i++; // работает
        b3+= 1000; // работает
        b3*= 2; // работает
        float f = 1.1f;
        b3/= f; // работает
        /* все сокращенные операторы автоматически преобразуют результат выражения к типу переменной,
        которой присваивается это значение. Например, b /= f; равносильно b = (byte)(b / f); */

        //ИНИЦИАЛИЗАЦИЯ ПО УМОЛЧАНИЮ
        // переменные полей класса или статические переменные инициализируются по умолчанию 0 или 0.0, char - пробелом, boolean - false;
        // обычные переменные могут быть обьявлены без инициализации, однако перед использованием они  ОБЯЗАТЕЛЬНО д.б. проинициализир.
        Primitives pr = new Primitives();
        System.out.println(pr.c4);
        System.out.println(pr.bol1);

        final byte a = 1;
        final byte b = 2;
        byte result = a + b;

        //К обычным вещественным числам добавляются еще четыре значения:
        //
        //  - положительная бесконечность, выражаемая константой POSITIVE_INFINITY и возникающая при переполнении
        //  положительного значения, например в результате операции умножения 3.0*6e307 или при делении на нуль;
        //  -отрицательная бесконечность NEGATIVE_INFINITY, возникающая при переполнении отрицательного значения,
        //  например в результате операции умножения -3.0*6e307 или при делении на нуль отрицательного числа;
        //  - "не число", записываемое константой NaN (Not a Number) и возникающее, например, при умножении нуля на бесконечность.
        //  - кроме того, стандарт различает положительный и отрицательный нуль,
        //  возникающий при делении на бесконечность соответствующего знака, хотя сравнение 0.0 == -0.0 дает в результате истину, true.
        // подробнее см. http://pr0java.blogspot.com/2015/04/java-float-double.html

        double inf = 1.0/0.0; //Бесконечность
        double neginf = -1.0/0;//Отрицательная бесконечность
        double negzero = -1.0/inf;// Отриц. ноль
        double plszero = 1.0/inf;// Положит. ноль
        double NaN1= 0.0/0.0; // Нечисловое знач
        double NaN2= 0.0*inf; // Нечисловое знач
        System.out.println("NaN1 ="+NaN1);
        System.out.println("NaN2 ="+NaN2);
        System.out.println("NaN1 == NaN2 is "+ (NaN1==NaN2));
        System.out.println("NaN1 != NaN2 is "+ (NaN1!=NaN2));

        boolean c = true;
        //теоретически, нам достаточно 1 бита информации, 0 или 1, то есть true или false.
        // Но на самом деле Boolean будет занимать больше памяти и это будет зависеть от конкретной реализации JVM.
        // Обычно на это тратится столько же, сколько на int.

        //Java не разрешает присваивать значения переменным больше, чем их макс значение.
        //Исключения - операторы ++,-- +=, -=, *=,/=. Т.е. нельзя int i8 = 2147483648;
        int i8 = 2147483647+1;
        System.out.println(i8);

        i8 = 200;
        long l2 = i8;
        l2 =300;
        System.out.println(Float.MAX_VALUE);
        System.out.println(Float.MIN_VALUE);
        System.out.println(Double.MIN_VALUE);
        System.out.println(Double.MAX_VALUE);
        System.out.println(Double.MAX_VALUE);


    }
}
